/**
 *
 * Error reporting service
 *
 * This module manage error reporting and auto error report sending (for now, only by mail)
 * To configure it, see the ERROR REPORTING section of the .env file.
 *
 */
const config = require("../config")

const {
	EXIT_CODES
} = require("../errors/constants")

let delayHandle
let failedAttempts = 0
let queue = []

module.exports = {

	/**
	 * Register an error for the next report
	 * 
	 * @param {string} msg Error description, catch context, any meaningful information that may help to debug.
	 * @param {Error} err The error to report.
	 * @return {Promise<void>}
	 */
	async report(msg, err) {
		queue.push({
			msg,
			err,
			date: (new Date()).toISOString()
		})

		if (config.errorReporting.policy === "instant") await this.flush()
	},

	/**
	 * Flush the error queue and immediately sends a report.
	 * If report sending fails ERR_REPORTING_MAX_ATTEMPTS_BEFORE_CRASH times, will flush with the logger
	 * and crash the server with EXIT_CODES.ERROR_REPORTING_FAILURE
	 * 
	 * @return {Promise<void>}
	 */
	async flush() {
		if (queue.length === 0) return

		try {
			if (config.errorReporting.mode === "no") {
				log.err(
					"kiss.errors.reporting - No reporting mode selected, flushing in console",
					queue.splice(0)
				)
			} else if (config.errorReporting.mode === "mail") {

				const subject = `⛔️ ERROR REPORT - kiss.server - ${config.errorReporting.instance}`

				const body =
					`The following errors occurred on ${config.errorReporting.instance} (kiss.server) and must be reported: \n\n
					${
						queue.splice(0)
							.map(report => `[${report.date}] ${report.msg}:\n<pre>${report.err.stack}\n\nError details:\n${JSON.stringify(report.err, Object.getOwnPropertyNames(report.err), 4)}</pre>`)
							.join("\n\n")
					}
					\n\nThis message have been auto-generated by an error reporting service. Please, don't reply.`

                await kiss.smtp.send({
                    to: config.errorReporting.recipients[0],
					cc: config.errorReporting.recipients.slice(1).join(","),
                    subject,
                    body,
					html: false
                })

			} else {
				throw new Error(`Unsupported error reporting mode: ${config.errorReporting.mode}`)
			}
		} catch (err) {
			log.err(`kiss.errors.reporting - Unable to report errors: `, err)
			failedAttempts++

			if (
				config.errorReporting.maxAttemptsBeforeCrash >= 0 &&
				failedAttempts >= config.errorReporting.maxAttemptsBeforeCrash
			) {
				log.err(
					"kiss.errors.reporting - ERR_REPORTING_MAX_ATTEMPTS_BEFORE_CRASH reached. Flushing in console: ",
					queue.splice(0)
				)
				process.exit(EXIT_CODES.ERROR_REPORTING_FAILURE)
			}

			return
		}

		failedAttempts = 0
	},

	/**
	 * Init the reporter by resetting the failed attempts counter, and the error queue.
	 */
	init() {
		queue = []
		failedAttempts = 0
	},

	/**
	 * Start the reporter to allow it to report errors every ERR_REPORTING_DELAY ms
	 */
	start() {
		if (config.errorReporting.policy === "instant") return

		delayHandle = setInterval(
			kiss.errors.reporting.flush,
			config.errorReporting.delay
		)
	},

	/**
	 * Stop the reporter. Will force a reporter flush, so the waiting errors are immediately sent.
	 * @return {Promise<void>}
	 */
	async stop() {
		if (config.errorReporting.policy === "instant") return

		clearInterval(delayHandle)
		delayHandle = undefined

		await this.flush()
	}
}